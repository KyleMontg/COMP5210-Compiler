from src.tac import TAC, Instruction
from src.tokens import Token, SYMBOLS
from src.errors import ASMError
"""
Windows X86 ASM

The first 4 parameters live at:
1) rcx
2) rdx
3) r8
4) r9
5+) on stack

frame pointer) rbp
return) rax

divisor) rax
temp register) rcx
"""

REGISTERS = ['r10', 'r11', 'r12', 'r13', 'r14', 'r15']
PARAM_REGS = ['rcx', 'rdx', 'r8', 'r9']


class RegAllocator:
    """Handles variable to register allocation
    """

    def __init__(self, reg_map: dict[str, int]):
        self.reg_map = dict()
        self.max_reg = len(REGISTERS) - 1  # 0 indexed
        self.offset = 8
        for var, reg_num in reg_map.items():
            if (reg_num > self.max_reg):
                self.reg_map[var] = f"[rbp - {self.offset}]"
                self.offset += 8
            else:
                self.reg_map[var] = REGISTERS[reg_num]

    def alloc_params(self, param_list: list[str]) -> None:
        """Allocates registers for parameters"""
        for param in param_list:
            self.reg_map[param] = f"[rbp - {self.offset}]"
            self.offset += 8

    def get_loc(self, token: Token) -> str:
        """Gets register of token if variable, returns number if number"""
        if token.type == 'NUMBER':
            return token.value
        elif token.type == 'IDENTIFIER':
            loc = self.reg_map.get(token.value)
            if (loc is None):
                raise ASMError(
                    f"Internal error: Variable '{token.value}' not found in register allocation map. "
                    f"Available variables: {list(self.reg_map.keys())}"
                )
            return loc
        raise ASMError(
            f"Cannot generate assembly for token type '{token.type}'. "
            f"Expected NUMBER or IDENTIFIER, got: {token}"
        )

    def get_stack_size(self) -> int:
        """Returns next 16 byte interval of stack offset"""
        size = self.offset
        # Align stack to next multiple of 16 bytes
        if size % 16 != 0:
            size = ((size // 16) + 1) * 16
        return size


def tac_to_asm(tac: TAC, reg_map: dict[str, int]) -> list[str]:
    """Takes in a Three Adress Code and creates Assembly

    Args:
        tac (TAC): Three Adress Code generated by tac.py
        reg_map (dict[str, int]): register mapping generated by register_optimization.py

    Returns:
        str: a list of strings that represents x84 Assembly for Windows X86
    """
    reg_alloc = RegAllocator(reg_map)
    asm = []
    func_list = tac.functions
    params = [param
              for func_blocks in func_list
              for param in func_blocks.params]
    reg_alloc.alloc_params(params)

    for func_blocks in func_list:
        asm.append(f"{func_blocks.name.value}:")
        generate_start_instr(asm, len(params), reg_alloc)
        instr_list = [
            instr
            for blocks in func_blocks.blocks
            for instr in blocks.instr_list
        ]
        parse_instructions(instr_list, asm, reg_alloc)
        generate_end_instr(asm, reg_alloc)

    return asm


def generate_start_instr(asm: list[str], param_count: int, reg_alloc: RegAllocator) -> None:
    """Stores registers that are used in this Assembly"""
    asm.append("\tpush rbp")
    asm.append("\tmov  rbp, rsp")

    stack_size = reg_alloc.get_stack_size()
    if stack_size > 0:
        asm.append(f"\tsub rsp, {stack_size}")

    asm.append("\tpush r12")
    asm.append("\tpush r13")
    asm.append("\tpush r14")
    asm.append("\tpush r15")
    asm.append("")
    asm.append("\t; Allocate registers for Parameters")
    for i in range(min(param_count, 4)):
        param_name = f'%param{i + 1}'
        param_loc = reg_alloc.reg_map.get(param_name)
        if param_loc:
            asm.append(f"\tmov {param_loc}, {PARAM_REGS[i]}")

    if param_count > 4:
        asm.append(
            f"\t; Parameters 5-{param_count} on stack")
    asm.append("")


def generate_end_instr(asm: list[str], reg_alloc: RegAllocator) -> None:
    """Frees up used registers"""
    asm.append("")
    asm.append("\tpop r15")
    asm.append("\tpop r14")
    asm.append("\tpop r13")
    asm.append("\tpop r12")
    stack_size = reg_alloc.get_stack_size()
    if stack_size > 0:
        asm.append(f"\tadd rsp, {stack_size}")
    asm.append("\tpop rbp")
    asm.append("\tret")


def parse_instructions(instr_list: list[Instruction], asm: list[str], reg_alloc: RegAllocator) -> None:
    """Handles instructions to turn into Assembly"""
    for instr in instr_list:

        if instr.instr_type == 'LABEL':
            asm.append(f".{instr.res}:")

        elif instr.instr_type == 'GOTO':
            asm.append(f"\tjmp .{instr.res}")

        elif instr.instr_type == 'DECL':
            decl_instr(instr, asm, reg_alloc)

        elif instr.instr_type == 'ASSIGN':
            assign_instr(instr, asm, reg_alloc)

        elif instr.instr_type in ('IF', 'WHILE', 'FOR'):
            conditional_instr(instr, asm, reg_alloc)

        elif instr.instr_type == 'RETURN':
            return_instr(instr, asm, reg_alloc)

        else:
            asm.append(f"\t; UNIMPLEMENTED: {instr.instr_type}")


def decl_instr(instr: Instruction, asm: list[str], reg_alloc: RegAllocator) -> None:
    """Handles declaration statements"""
    assert isinstance(instr.res, Token)
    assert isinstance(instr.left, Token)
    store_reg = reg_alloc.get_loc(instr.res)
    if (instr.left is None):
        asm.append(f"\t; {instr.res.value} declared")
        return
    access_reg = reg_alloc.get_loc(instr.left)
    asm.append(f"\t; {instr.res.value} = {instr.left.value}")
    asm.append(f"\tmov {store_reg}, {access_reg}")


def assign_instr(instr: Instruction, asm: list[str], reg_alloc: RegAllocator) -> None:
    """Handles assign instrucitons, passes off binary expressions"""
    assert isinstance(instr.res, Token)
    assert isinstance(instr.left, Token)
    # If assign instruction
    if instr.op is None:
        store_reg = reg_alloc.get_loc(instr.res)
        access_reg = reg_alloc.get_loc(instr.left)
        asm.append(f"\t; {instr.res.value} = {access_reg}")
        asm.append(f"\tmov {store_reg}, {access_reg}")
    # If binary operation
    else:
        binary_instr(instr, asm, reg_alloc)


def binary_instr(instr: Instruction, asm: list[str], reg_alloc: RegAllocator):
    """Handles all binary operations"""
    assert isinstance(instr.res, Token)
    assert isinstance(instr.left, Token)
    assert isinstance(instr.right, Token)
    assert isinstance(instr.op, Token)
    # Get variable registers
    store_reg = reg_alloc.get_loc(instr.res)
    left_reg = reg_alloc.get_loc(instr.left)
    right_reg_temp = reg_alloc.get_loc(instr.right)
    op_type = instr.op.type
    op_symbol = None
    # Find Symbol Name
    for key, value in SYMBOLS.items():
        if (value == instr.op.type):
            op_symbol = key
            break
    # Operation hint
    asm.append(
        f"\t; {instr.res.value}"
        + f" = {instr.left.value}"
        + f"{op_symbol} {instr.right.value}")
    # Determines if two variables share same register and used back to back
    needs_temp = (store_reg == right_reg_temp
                  and instr.res.value != instr.right.value
                  and not right_reg_temp.startswith('[')
                  and not right_reg_temp.isdigit())

    temp_reg = "rcx"
    # If temp is needed mive right register into temp register
    if needs_temp:
        asm.append(f"\tmov {temp_reg}, {right_reg_temp}")
        right_reg = temp_reg
    else:
        right_reg = right_reg_temp

    if op_type == 'PLUS':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tadd {store_reg}, {right_reg}")

    elif op_type == 'MINUS':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tsub {store_reg}, {right_reg}")

    elif op_type == 'MULTIPLY':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\timul {store_reg}, {right_reg}")

    elif op_type == 'DIVIDE':
        # Use rax for division
        asm.append(f"\tmov rax, {left_reg}")
        asm.append(f"\tcqo")
        # Handle positive and negative numbers
        if right_reg.isdigit() or (right_reg[0] == '-' and right_reg[1:].isdigit()):
            asm.append(f"\tmov rcx, {right_reg}")
            asm.append(f"\tidiv rcx")
        else:
            asm.append(f"\tidiv {right_reg}")
        asm.append(f"\tmov {store_reg}, rax")

    elif op_type == 'MODULUS':
        # Use rax for division
        asm.append(f"\tmov rax, {left_reg}")
        asm.append(f"\tcqo")
        # Handle positive and negative numbers
        if right_reg.isdigit() or (right_reg[0] == '-' and right_reg[1:].isdigit()):
            asm.append(f"\tmov rcx, {right_reg}")
            asm.append(f"\tidiv rcx")
        else:
            asm.append(f"\tidiv {right_reg}")
        # rdx for remainder
        asm.append(f"\tmov {store_reg}, rdx")

    elif op_type == 'LESSTHAN':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tcmp {store_reg}, {right_reg}")
        asm.append(f"\tsetl al")
        asm.append(f"\tmovzx {store_reg}, al")

    elif op_type == 'GREATERTHAN':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tcmp {store_reg}, {right_reg}")
        asm.append(f"\tsetg al")
        asm.append(f"\tmovzx {store_reg}, al")

    elif op_type == 'EQUAL':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tcmp {store_reg}, {right_reg}")
        asm.append(f"\tsete al")
        asm.append(f"\tmovzx {store_reg}, al")

    elif op_type == 'NOTEQUAL':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tcmp {store_reg}, {right_reg}")
        asm.append(f"\tsetne al")
        asm.append(f"\tmovzx {store_reg}, al")

    elif op_type == 'LESSTHANEQUAL':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tcmp {store_reg}, {right_reg}")
        asm.append(f"\tsetle al")
        asm.append(f"\tmovzx {store_reg}, al")

    elif op_type == 'GREATERTHANEQUAL':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tcmp {store_reg}, {right_reg}")
        asm.append(f"\tsetge al")
        asm.append(f"\tmovzx {store_reg}, al")

    elif op_type == 'INCREMENT':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tinc {store_reg}")

    elif op_type == 'DECREMENT':
        asm.append(f"\tmov {store_reg}, {left_reg}")
        asm.append(f"\tdec {store_reg}")

    else:
        asm.append(f"\t; UNIMPLEMENTED OPERATION: {op_type}")


def conditional_instr(instr: Instruction, asm: list[str], reg_alloc: RegAllocator) -> None:
    assert isinstance(instr.res, Token)
    condition = reg_alloc.get_loc(instr.res)
    true_label = instr.left
    false_label = instr.right

    asm.append(f"\t; if {condition} goto .{true_label} else .{false_label}")
    asm.append(f"\tcmp {condition}, 1")
    asm.append(f"\tje .{true_label}")
    asm.append(f"\tjmp .{false_label}")


def return_instr(instr: Instruction, asm: list[str], reg_alloc: RegAllocator) -> None:
    if instr.res is not None:
        assert isinstance(instr.res, Token)
        ret_val = reg_alloc.get_loc(instr.res)
        asm.append(f"\t; return {ret_val}")
        asm.append(f"\tmov rax, {ret_val}")
    else:
        asm.append(f"\t; return (void)")
